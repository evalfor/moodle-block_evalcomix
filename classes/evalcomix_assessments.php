<?php//defined('MOODLE_INTERNAL') || die();include_once('evalcomix_object.php');include_once('evalcomix_modes.php');//include_once('evalcomix_tasks.php');//include_once('evalcomix.php');/** * @package    block_evalcomix * @copyright  2010 onwards EVALfor Research Group {@link http://evalfor.net/} * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later * @author     Daniel Cabeza Sánchez <daniel.cabeza@uca.es>, Juan Antonio Caballero Hernández <juanantonio.caballero@uca.es> */  class evalcomix_assessments extends evalcomix_object{	 public $table = 'block_evalcomix_assessments';	 	 /**     * Array of required table fields, must start with 'id'.     * @var array $required_fields     */    public $required_fields = array('id', 'taskid', 'assessorid', 'studentid', 'grade', 'timemodified');	/**     * Array of optional table fields.     * @var array $required_fields     */    public $optional_fields = array();		/**	* course_module ID associated	* @var int $instanceid	*/	public $taskid;		/**	* Assessor ID associated	* @var int $assessorid	*/	public $assessorid;	/**	* Student ID associated	* @var int $studentid	*/	public $studentid;		/**	* Grade	* @var int $grade	*/	public $grade;	    /**     * The last time this evalcomix_assessment was modified.     * @var int $timemodified     */    public $timemodified;		/**	* Constructor	*	* @param int $id ID	* @param int $instanceid //foreign key of table 'block_evalcomix_tasks'	* @param int $assessorid //foreign key of table 'user'	* @param int $studentid //foreign key of table 'user'	* @param float $grade Grade	* @param int $timemodified	*/	public function __construct($id = '', $taskid = '0', $assessorid = '0', $studentid = '0', $grade = '0', $timemodified = '0'){		global $DB;		$this->id = intval($id);		$this->grade = $grade;		$this->timemodified = 0;		//Por si queremos crear una instancia vacía (para usar evalcomix_object::fetch_all_helper es necesario)		if (is_numeric($taskid) && !is_float($taskid) && (int)$taskid > 0) {		//if ($taskid != '0'){			$task = $DB->get_record('block_evalcomix_tasks', array('id'=>$taskid), '*', MUST_EXIST);			$this->taskid = $task->id;		}		else {			$this->taskid = 0;		}				//Por si queremos crear una instancia vacía (para usar evalcomix_object::fetch_all_helper es necesario)		if (is_numeric($assessorid) && !is_float($assessorid) && $assessorid > '0'){		//if($assessorid != '0'){			$assessor = $DB->get_record('user', array('id'=>$assessorid), '*', MUST_EXIST);			$this->assessorid = $assessor->id;		}		else {			$this->assessorid = 0;		}				//Por si queremos crear una instancia vacía (para usar evalcomix_object::fetch_all_helper es necesario)		if (is_numeric($studentid) && !is_float($studentid) && $studentid > '0'){		//if($studentid != '0'){			$student = $DB->get_record('user', array('id'=>$studentid), '*', MUST_EXIST);			$this->studentid = $student->id;		}		else {			$this->studentid = 0;		}			}		 /**     * Updates this object in the Database, based on its object variables. ID must be set.     * @param string $source from where was the object updated (mod/forum, manual, etc.)     * @return boolean success     */	public function update(){		global $DB;        if (empty($this->id)) {            debugging('Can not update assessment object, no id!');            return false;        }		$this->timemodified = time();		        $data = $this->get_record_data();        $DB->update_record($this->table, $data);        $this->notify_changed(false);        return true;	}		/**     * Updates this object in the Database, based on its object variables. ID must be set.     * @param string $source from where was the object updated (mod/forum, manual, etc.)     * @return boolean success     */	/*public function delete(){		global $DB;        if (empty($this->id)) {            debugging('Can not delete assessment object, no id!');            return false;        }				        //$data = $this->get_record_data();		        $DB->delete_records($this->table, array('id' => $this->id));        $this->notify_changed(false);        return true;	}*/			/**     * Calculate evalcomix final grade.     * @static abstract     * @param array $users	 * @param int $courseid     * @return array $finalgrades with two dimensions [$taskinstance][$userid] that contains the finalgrades.     */	public static function get_final_grade($courseid, $users){		global $CFG, $COURSE;		include_once($CFG->dirroot . '/blocks/evalcomix/classes/evalcomix_tasks.php');		include_once($CFG->dirroot . '/blocks/evalcomix/classes/evalcomix.php');				//$coursecontext = get_context_instance(CONTEXT_COURSE, $courseid);		$coursecontext = context_course::instance($courseid);		$finalgrades = array();				$tasks = evalcomix_tasks::get_tasks_by_courseid($courseid);		$now = time();				foreach($tasks as $task){			$teacherweight = 0;			$selfweight = 0;			$peerweight = 0;					$params = array('taskid' => $task->id);			$modes = evalcomix_modes::fetch_all($params);			if($modes){				//Obtains activity´s weights				foreach($modes as $mode){					switch($mode->modality){						case 'teacher': $teacherweight = $mode->weighing; break;						case 'self': $selfweight = $mode->weighing; break;						case 'peer': $peerweight = $mode->weighing; break;						default:					}								}				//echo $task->id . ': teacherweight-' . $teacherweight . ' selfweight-' .$selfweight . ' peerweight-' .$peerweight.'<br/>';								foreach($users as $user){					//It obtains assignments for each task and user					$params2 = array('taskid' => $task->id, 'studentid' => $user->id);					$assessments = evalcomix_assessments::fetch_all($params2);					if($assessments){						//$selfgrade = 0;													$selfgrade = -1;						$teachergrade = 0;						$numteachers = 0;						$peergrade = 0;						$numpeers = 0;						$grade = 0;						foreach($assessments as $assessment){													//If it is a self assessment							if ($assessment->studentid == $assessment->assessorid && $selfweight){								$selfgrade = $assessment->grade;							}							//If it is a teacher assessment							//elseif (has_capability('block/evalcomix:edit',$coursecontext, $assessment->assessorid) && $teacherweight){							elseif (has_capability('moodle/grade:viewhidden',$coursecontext, $assessment->assessorid) && $teacherweight){								$teachergrade += $assessment->grade;								$numteachers++;							}							else { //If it is a peer assessment								//Only gets grades when the assessment period in the task is finished																if($modeEI = evalcomix_modes::fetch(array('taskid' => $assessment->taskid, 'modality' => 'peer'))){									$modeEItime = evalcomix_modes_time::fetch(array('modeid' => $modeEI->id));									if ($modeEItime && $now > $modeEItime->timedue) {										$peergrade += $assessment->grade;										$numpeers++;									}								}							}														}												//Calculates peergrade						if($numpeers > 0){							$peergrade = round($peergrade/$numpeers, 2);						}						//Calculates teachergrade						if($numteachers > 0){							$teachergrade = round($teachergrade/$numteachers, 2);						}						//Calcultes the total grade						//if($teachergrade != 0 || $selfgrade != 0 || $peergrade != 0){						if($numteachers > 0 || $numpeers > 0 || $selfgrade != -1){							if($selfgrade == -1){								$selfgrade = 0;							}							$totalgrade = $selfgrade * ($selfweight/100) + $teachergrade * ($teacherweight/100) + $peergrade * ($peerweight/100);							//Add grade to array final grades							//$finalgrades[$task->id][$user->id] = $totalgrade;							$finalgrades[$task->instanceid][$user->id] = $totalgrade;						}						else{							//There is peer assessments but assessment period hasn't finished							$finalgrades[$task->instanceid][$user->id] = -1;						}					}				}								}		}				return $finalgrades;			}			 /**     * Finds and returns all evalcomix_assessments instances.     * @static abstract     * @param array $params     * @return array array of evalcomix_assessments instances or false if none found.     */	public static function fetch_all($params){		return evalcomix_object::fetch_all_helper('block_evalcomix_assessments', 'evalcomix_assessments', $params);	}			/**     * Finds and returns one evalcomix_tool instances.     * @static abstract     * @param array $params     * @return an object instance or false if not found     */	public static function fetch($params){		return evalcomix_object::fetch_helper('block_evalcomix_assessments', 'evalcomix_assessments', $params);	}		/**     * Called immediately after the object data has been inserted, updated, or     * deleted in the database. Default does nothing, can be overridden to     * hook in special behaviour.     *     * @param bool $deleted     */    function notify_changed($deleted) {    }		/**	* @param int $taskid	* @param int $userid	* @return object with evalcomix_assessment objects by modality and their weighings	*/	public static function get_assessments_by_modality($taskid, $userid){	    global $CFG, $DB;		include_once($CFG->dirroot .'/blocks/evalcomix/classes/evalcomix_modes.php');		include_once($CFG->dirroot .'/blocks/evalcomix/classes/evalcomix_tasks.php');		$assessments = evalcomix_assessments::fetch_all(array('studentid' => $userid, 'taskid' => $taskid));		if($assessments){			if(!$task = evalcomix_tasks::fetch(array('id' => $taskid))){				return false;			}			$cm = $DB->get_record('course_modules', array('id' => $task->instanceid));			//$context = get_context_instance(CONTEXT_COURSE, $cm->course);			$context = context_course::instance($cm->course);			$selfassessment = null;			$teacherassessment = array();			$peerassessments = array();			$weighingteacher = null;			$weighingself = null;			$weighingpeer = null;						foreach($assessments as $assessment){				/*$course_id      = <some value>;				$role_id        = get_field('role', 'id', 'shortname', 'editingteacher');				$course_context = get_context_instance(CONTEXT_COURSE, $course_id);				$isthere        = user_has_role_assignment($USER->id, $role_id, $course_context->id);				*/				//if(has_capability('block/evalcomix:edit', $context, $assessment->assessorid)){				if(has_capability('moodle/grade:viewhidden', $context, $assessment->assessorid)){					if($modality = evalcomix_modes::fetch(array('taskid' => $taskid, 'modality' => 'teacher'))){						$weighingteacher = $modality->weighing;						array_push($teacherassessment,$assessment);					}				}				elseif($assessment->assessorid == $userid){					if($modality = evalcomix_modes::fetch(array('taskid' => $taskid, 'modality' => 'self'))){						$weighingself = $modality->weighing;						$selfassessment = $assessment;					}				}				else{					if($modality = evalcomix_modes::fetch(array('taskid' => $taskid, 'modality' => 'peer'))){						$weighingpeer = $modality->weighing;						array_push($peerassessments, $assessment);					}				}			}						$result = new stdClass();			$result->teacherassessments = $teacherassessment;			$result->weighingteacher = $weighingteacher;			$result->selfassessment = $selfassessment;			$result->weighingself = $weighingself;			$result->peerassessments = $peerassessments;			$result->weighingpeer = $weighingpeer;						return $result;		}		return false;	}		/**	* @param array $assessments array of evalcomix_assessments objects	* @return double|false result of current implementation of icalculator interface of false if $assessment is empty	*/	public static function calculate_gradearray($assessments){		if(!empty($assessments)){			$grades = array();			foreach($assessments as $assessment){				array_push($grades, $assessment->grade);			}			$result = calculator_average::calculate_one_array($grades);			return $result;		}		return false;	}		/**	* @param array $assessments array of evalcomix_assessments objects	* @return array|false result of current implementation of icalculator interface of false if $assessment is empty	*/	public static function calculate_grades($assessments){		if(!empty($assessments)){			$grades = array();			foreach($assessments as $assessment){				array_push($grades, $assessment->grade);			}			return $grades;		}		return false;	}		/**	* @param int $taskid	* @return array of IDs of student assessed in $taskid	*/	public static function get_students_assessed($taskid){		$assessments = evalcomix_assessments::fetch_all(array('taskid' => $taskid));		$students = array();		if($assessments){			foreach($assessments as $assessment){				array_push($students, $assessment->studentid);			}			$result = array_unique($students);			return $result;		}		return false;	}		/**	* @param int $taskid	* @param int $userid	* @return object with assessment of student $userid in $taskid	*/	public static function get_grade_by_user_task($taskid, $userid){		$assessments = evalcomix_assessments::fetch(array('studentid' => $userid, 'taskid' => $taskid));		return $assessments;	} }?>